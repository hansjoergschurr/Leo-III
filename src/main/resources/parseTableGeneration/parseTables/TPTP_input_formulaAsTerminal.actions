Z0 ->
   TPTP_input action_0
TPTP_input ->
   annotated_formula action_1
  |include action_2
annotated_formula ->
   thf_annotated action_3
thf_annotated ->
   "thf" "(" name "," formula_role "," "thf_formula" annotations ")" "." action_4 { TokenEntry(Dot) :: TokenEntry(RightParenthesis) :: AnnotationsEntry(annotations) :: FormulaEntry(f) :: TokenEntry(Comma) :: StringEntry(role) :: TokenEntry(Comma) :: StringEntry(name) :: TokenEntry(LeftParenthesis) :: TokenEntry(THF) :: rest => TPTPEntry(Left(THFAnnotated(name, role, f, annotations))) :: rest }
name ->
   atomic_word action_5 { TokenEntry(tok: LowerWord | SingleQuoted) :: rest => StringEntry(tok.data) :: rest }
  |"integer" action_6 { TokenEntry(Integer(x)) :: rest => StringEntry(x.toString) :: rest }
atomic_word ->
   "lower_word" action_7
  |"single_quoted" action_8
formula_role ->
   "lower_word" action_9 { TokenEntry(t: LowerWord) :: rest => StringEntry(t.data) :: rest }
annotations ->
   "," source optional_info action_10 { GeneralTermsEntry(optInfo) :: GeneralTermEntry(source) :: TokenEntry(Comma) :: rest => AnnotationsEntry(Some((source,optInfo))) :: rest }
  |null action_11 { rest => AnnotationsEntry(None) :: rest }
source ->
   general_term action_12
general_term ->
   general_data action_13 { GeneralDataEntry(data) :: rest => GeneralTermEntry(GeneralTerm(List(Left(data)))) :: rest }
  |general_data ":" general_term action_14 { GeneralTermEntry(gterm) :: TokenEntry(Colon) :: GeneralDataEntry(data) :: rest => GeneralTermEntry(GeneralTerm(Left(data) :: gterm.term)) :: rest }
  |general_list action_15 { GeneralTermsEntry(terms) :: rest => GeneralTermEntry(GeneralTerm(List(Right(terms)))) :: rest }
general_data ->
   atomic_word action_16 { TokenEntry(x: LowerWord|SingleQuoted) :: rest => GeneralDataEntry(GWord(x.data)) :: rest }
  |general_function action_17
  |variable action_18 { TokenEntry(UpperWord(x)) :: rest => GeneralDataEntry(GVar(x)) :: rest }
  |number action_19 { NumberEntry(x) :: rest => GeneralDataEntry(GNumber(x)) :: rest }
  |"distinct_object" action_20 { TokenEntry(x: DistinctObject) :: rest => GeneralDataEntry(GDistinct(x.chars)) :: rest }
  |formula_data action_21
general_function ->
   atomic_word "(" general_terms ")" action_22 { TokenEntry(RightParenthesis) :: GeneralTermsEntry(terms) :: TokenEntry(LeftParenthesis) :: TokenEntry((LowerWord|SingleQuoted)(name)) :: rest => GeneralDataEntry(GFunc(name, terms)) :: rest }
general_terms ->
   general_term action_23 { GeneralTermEntry(term) :: rest => GeneralTermsEntry(List(term)) :: rest }
  |general_term "," general_terms action_24 { GeneralTermsEntry(terms) :: TokenEntry(Comma) :: GeneralTermEntry(term) :: rest => GeneralTermsEntry(term :: terms) :: rest }
variable ->
   "upper_word" action_25
number ->
   "integer" action_26 { TokenEntry(x: Integer) :: rest => NumberEntry(IntegerNumber(x.value)) :: rest }
  |"rational" action_27 { TokenEntry(Rational(p,q)) :: rest => NumberEntry(RationalNumber(p,q)) :: rest }
  |"real" action_28 { TokenEntry(Real(coeff,exp)) :: rest => NumberEntry(DoubleNumber(coeff * Math.pow(10,exp))) :: rest }
formula_data ->
   "$thf" "(" "thf_formula" ")" action_29 { TokenEntry(RightParenthesis) :: FormulaEntry(f) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$thf")) :: rest => GeneralDataEntry(GFormulaData(THFData(f))) :: rest }
  |"$fot" "(" "term" ")" action_30 { TokenEntry(RightParenthesis) :: TermEntry(t) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$fot")) :: rest => GeneralDataEntry(GFormulaData(FOTData(t))) :: rest }
general_list ->
   "[" "]" action_31 { TokenEntry(RightBracket) :: TokenEntry(LeftBracket) :: rest => GeneralTermsEntry(List.empty) :: rest }
  |"[" general_terms "]" action_32 { TokenEntry(RightBracket) :: GeneralTermsEntry(terms) :: TokenEntry(LeftBracket) :: rest => GeneralTermsEntry(terms) :: rest }
optional_info ->
   "," useful_info action_33 { (x: GeneralTermsEntry) :: TokenEntry(Comma) :: rest => x :: rest }
  |null action_34 { rest => GeneralTermsEntry(List.empty) :: rest }
useful_info ->
   general_list action_35
null ->
   "" action_36
include ->
   "include" "(" file_name formula_selection ")" "." action_37 { TokenEntry(Dot) :: TokenEntry(RightParenthesis) :: StringsEntry(formulaSelections) :: TokenEntry(SingleQuoted(fileName)) :: TokenEntry(LeftParenthesis) :: TokenEntry(IncludeToken) :: rest => TPTPEntry(Right((fileName, formulaSelections))) :: rest }
file_name ->
   "single_quoted" action_38
formula_selection ->
   "," "[" name_list "]" action_39 { TokenEntry(RightBracket) :: (names: StringsEntry) :: TokenEntry(LeftBracket) :: TokenEntry(Comma) :: rest => names :: rest }
  |null action_40 { rest => StringsEntry(List.empty) :: rest }
name_list ->
   name action_41 { StringEntry(str) :: rest => StringsEntry(List(str)) :: rest }
  |name "," name_list action_42 { StringsEntry(strRest) :: TokenEntry(Comma) :: StringEntry(str) :: rest => StringsEntry(str :: strRest) :: rest }

		/* this is the type of the nodes of the abstract syntax tree: */
    sealed class StackEntry
		case class TokenEntry(data: Token) extends StackEntry
 		case class TPTPEntry(data: Either[AnnotatedFormula, Include]) extends StackEntry
    case class FormulaEntry(data: thf.Formula) extends StackEntry
    case class TermEntry(data: Term) extends StackEntry
    case class AnnotationsEntry(data: Annotations) extends StackEntry
    case class GeneralTermEntry(data: GeneralTerm) extends StackEntry
    case class GeneralTermsEntry(data: List[GeneralTerm]) extends StackEntry
    case class GeneralDataEntry(data: GeneralData) extends StackEntry
    case class NumberEntry(data: Number) extends StackEntry
    case class StringEntry(data: String) extends StackEntry
    case class StringsEntry(data: List[String]) extends StackEntry

  // Files
  sealed case class TPTPInput(inputs: Seq[Either[AnnotatedFormula, Include]]) {
    def getIncludes:Seq[Include] = inputs.filter(x => x.isRight).map(_.right.get)
    def getIncludeCount: Int = getIncludes.size
    def getFormulae:Seq[AnnotatedFormula] = inputs.filter(x => x.isLeft).map(_.left.get)
    def getFormulaeCount: Int = getFormulae.size
  }

  // Formula records
  sealed abstract class AnnotatedFormula(val name: Name, val role: Role,val annotations: Annotations) {
    type FormulaType
    def f: FormulaType

    lazy val rep = "(" + name + "," + role + "," + "(" + f.toString + ")" + annoToString(annotations) + ")."
  }
  case class TPIAnnotated(override val name: Name,override val role: Role,formula: fof.Formula,override val annotations: Annotations) extends AnnotatedFormula(name, role, annotations) {
    override type FormulaType = fof.Formula
    override def f = formula

    override def toString = "tpi" + rep
  }
  case class THFAnnotated(override val name: Name, override val role: Role, formula: thf.Formula,override val annotations: Annotations) extends AnnotatedFormula(name, role, annotations) {
    override type FormulaType = thf.Formula
    override def f = formula

    override def toString = "thf" + rep
  }
  case class TFFAnnotated(override val name: Name, override val role: Role, formula: tff.Formula, override val annotations: Annotations) extends AnnotatedFormula(name, role, annotations) {
    override type FormulaType = tff.Formula
    override def f = formula

    override def toString = "tff" + rep
  }
  case class FOFAnnotated(override val name: Name, override val role: Role, formula: fof.Formula, override val annotations: Annotations) extends AnnotatedFormula(name, role, annotations) {
    override type FormulaType = fof.Formula
    override def f = formula

    override def toString = "fof" + rep
  }
  case class CNFAnnotated(override val name: Name, override val role: Role, formula: cnf.Formula,override val annotations: Annotations) extends AnnotatedFormula(name, role, annotations) {
    override type FormulaType = cnf.Formula
    override def f = formula

    override def toString = "cnf" + rep
  }

  type Annotations = Option[(Source, List[GeneralTerm])]
  type Role = String

	...

  type Variable = String

  // System terms

  // General purpose things
  type Source = GeneralTerm

  // Include directives
  type Include = (String, List[Name])

  // Non-logical data (GeneralTerm, General data)
  sealed case class GeneralTerm(term: List[Either[GeneralData, List[GeneralTerm]]]) {
    override def toString = term.map(gt2String).mkString(":")

    def gt2String(in: Either[GeneralData, List[GeneralTerm]]): String = in match {
      case Left(data) => data.toString
      case Right(termList) => "[" + termList.mkString(",") +"]"
    }

  }

  sealed abstract class GeneralData
  case class GWord(gWord: String) extends GeneralData {
    override def toString = gWord
  }
  case class GFunc(name: String, args: List[GeneralTerm]) extends GeneralData {
    override def toString = funcToString(name, args)
  }
  case class GVar(gVar: Variable) extends GeneralData {
    override def toString = gVar.toString
  }
  case class GNumber(gNumber: Number) extends GeneralData {
    override def toString = gNumber.toString
  }
  case class GDistinct(data: String) extends GeneralData {
    override def toString = data
  }
  case class GFormulaData(data: FormulaData) extends GeneralData {
    override def toString = data.toString
  }

  sealed abstract class FormulaData
  case class THFData(formula: thf.Formula) extends FormulaData {
    override def toString = "$thf(" + formula.toString + ")"
  }
  case class TFFData(formula: tff.Formula) extends FormulaData {
    override def toString = "$tff(" + formula.toString + ")"
  }
  case class FOFData(formula: fof.Formula) extends FormulaData {
    override def toString = "$fof(" + formula.toString + ")"
  }
  case class CNFData(formula: cnf.Formula) extends FormulaData {
    override def toString = "$cnf(" + formula.toString + ")"
  }
  case class FOTData(term: Term) extends FormulaData {
    override def toString = "$fot(" + term.toString + ")"
  }

  // General purpose
  type Name = String


  ///////// String representation functions ///////////
  def funcToString(name:String, args: List[Any]) = args match {
    case List()     => name
    case _          => name + "(" + args.mkString(",") + ")"
  }

  def annoToString(anno: Option[(Source, List[GeneralTerm])]) = anno match {
    case None => ""
    case Some((src, termList)) => "," + src.toString + ",[" + termList.mkString(",") + "]"
  }

  def typedVarToString(input: (Variable,Option[Any])) = input match {
    case (v, None) => v.toString
    case (v, Some(typ)) => v.toString + " : " + typ.toString
  }
