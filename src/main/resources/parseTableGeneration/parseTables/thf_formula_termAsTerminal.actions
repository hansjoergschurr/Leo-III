Z0 ->
   thf_formula action_0
thf_formula ->
   thf_logic_formula action_1 { LogicFormulaEntry(f) :: rest => FormulaEntry(f) :: rest }
  |thf_sequent action_2
thf_logic_formula ->
   thf_binary_formula action_3
  |thf_unitary_formula action_4
  |thf_type_formula action_5
  |thf_subtype action_6
thf_binary_formula ->
   thf_binary_pair action_7
  |thf_binary_tuple action_8
  |thf_binary_type action_9
thf_binary_pair ->
   thf_unitary_formula thf_pair_connective thf_unitary_formula action_10 { LogicFormulaEntry(f2) :: BinaryConnectiveEntry(conn) :: LogicFormulaEntry(f1) :: rest => LogicFormulaEntry( Binary(left=f1, connective=conn, right=f2 ) ) :: rest }
thf_unitary_formula ->
   thf_quantified_formula action_11
  |thf_unary_formula action_12
  |thf_atom action_13
  |thf_conditional action_14
  |thf_let action_15
  |"(" thf_logic_formula ")" action_16 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: rest => LogicFormulaEntry(f) :: rest }
thf_quantified_formula ->
   thf_quantifier "[" thf_variable_list "]" ":" thf_unitary_formula action_17 { LogicFormulaEntry(f) :: TokenEntry(Colon) :: TokenEntry(RightBracket) :: VarsEntry(vars) :: TokenEntry(LeftBracket) :: QuantifierEntry(q) :: rest => LogicFormulaEntry(Quantified(quantifier=q, varList=vars, matrix=f )) :: rest }
thf_quantifier ->
   fol_quantifier action_18 { TokenEntry(x) :: rest => QuantifierEntry(quantifierFromToken_1(x)) :: rest }
  |"^" action_19 { action_18 }
  |"!" "arrow" action_20 { TokenEntry(x2) :: TokenEntry(x1) :: rest => QuantifierEntry(quantifierFromToken_2(x1,x2)) :: rest }
  |"?" "star" action_21 { action_20 }
  |"@" "plus" action_22 { action_20 }
  |"@" "-" action_23 { action_20 }
fol_quantifier ->
   "!" action_24
  |"?" action_25
thf_variable_list ->
   thf_variable action_26 { VarEntry(v) :: rest => VarsEntry(List(v)) :: rest }
  |thf_variable "," thf_variable_list action_27 { VarsEntry(vars) :: TokenEntry(Comma) :: VarEntry(v) :: rest => VarsEntry(v :: vars) :: rest }
thf_variable ->
   thf_typed_variable action_28
  |variable action_29
thf_typed_variable ->
   variable ":" thf_top_level_type action_30 { LogicFormulaEntry(t) :: TokenEntry(Colon) :: VarEntry((v, None)) :: rest => VarEntry((v, Some(t))) :: rest }
variable ->
   "upper_word" action_31 { TokenEntry(UpperWord(v)) :: rest => VarEntry((v, None)) :: rest }
thf_top_level_type ->
   thf_logic_formula action_32
thf_unary_formula ->
   thf_unary_connective "(" thf_logic_formula ")" action_33 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: UnaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Unary(connective=conn, formula=f)) :: rest }
thf_unary_connective ->
   unary_connective action_34
  |"!" "!" action_35 { TokenEntry(Exclamationmark) :: TokenEntry(Exclamationmark) :: rest => UnaryConnectiveEntry(!!) :: rest }
  |"?" "?" action_36 { TokenEntry(Questionmark) :: TokenEntry(Questionmark) :: rest => UnaryConnectiveEntry(??) :: rest }
unary_connective ->
   "~" action_37 { TokenEntry(Tilde) :: rest => UnaryConnectiveEntry(~) :: rest }
thf_atom ->
   "term" action_38 { TermEntry(t) :: rest => LogicFormulaEntry(Term(t)) :: rest }
  |thf_conn_term action_39
thf_conn_term ->
   thf_pair_connective action_40 { BinaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Connective(Left(conn))) :: rest }
  |assoc_connective action_41 { action_40 }
  |thf_unary_connective action_42 { UnaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Connective(Right(conn))) :: rest }
thf_pair_connective ->
   infix_equality action_43
  |infix_inequality action_44
  |binary_connective action_45
infix_equality ->
   "=" action_46 { TokenEntry(x) :: rest => BinaryConnectiveEntry(binaryConnectiveFromToken_1(x)) :: rest }
infix_inequality ->
   "!=" action_47 { action_46 }
binary_connective ->
   "less_eq_greater" action_48 { action_46 }
  |"=>" action_49 { action_46 }
  |"less_eq" action_50 { action_46 }
  |"less_tilde_greater" action_51 { action_46 }
  |"~vline" action_52 { action_46 }
  |"~&" action_53 { action46 }
assoc_connective ->
   "vline" action_54 { action_46 }
  |"&" action_55 { action_46 }
thf_conditional ->
   "$ite_f" "(" thf_logic_formula "," thf_logic_formula "," thf_logic_formula ")" action_56 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(elseFormula) :: TokenEntry(Comma) :: LogicFormulaEntry(thenFormula) :: TokenEntry(Comma) :: LogicFormulaEntry(condFormula) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$ite_f")) :: rest => LogicFormulaEntry(Cond(cond=condFormula, thn=thenFormula, els=elseFormula)) :: rest }
thf_let ->
   "$let_tf" "(" thf_let_term_defn "," thf_formula ")" action_57 { TokenEntry(RightParenthesis) :: FormulaEntry(f) :: TokenEntry(Comma) :: LogicFormulaEntry(let_def: Quantified) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$let_tf")) :: rest => LogicFormulaEntry(Let(TermBinding(let_def),f)) :: rest }
  |"$let_ff" "(" thf_let_formula_defn "," thf_formula ")" action_58 { TokenEntry(RightParenthesis) :: FormulaEntry(f) :: TokenEntry(Comma) :: LogicFormulaEntry(let_def: Quantified) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$let_ff")) :: rest => LogicFormulaEntry(Let(FormulaBinding(let_def),f)) :: rest }
thf_let_term_defn ->
   thf_quantified_formula action_59
thf_let_formula_defn ->
   thf_quantified_formula action_60
thf_binary_tuple ->
   thf_or_formula action_61
  |thf_and_formula action_62
  |thf_apply_formula action_63
thf_or_formula ->
   thf_unitary_formula "vline" thf_unitary_formula action_64 { LogicFormulaEntry(f2) :: TokenEntry(conn) :: LogicFormulaEntry(f1) :: rest => LogicFormulaEntry(Binary(left=f1, connective= binaryConnectiveFromToken_1(conn), right=f2)) :: rest }
  |thf_or_formula "vline" thf_unitary_formula action_65 { action_64 }
thf_and_formula ->
   thf_unitary_formula "&" thf_unitary_formula action_66 { action_64 }
  |thf_and_formula "&" thf_unitary_formula action_67 { action_64 }
thf_apply_formula ->
   thf_unitary_formula "@" thf_unitary_formula action_68 { action_64 }
  |thf_apply_formula "@" thf_unitary_formula action_69 { action_64 }
thf_binary_type ->
   thf_mapping_type action_70
  |thf_xprod_type action_71
  |thf_union_type action_72
thf_mapping_type ->
   thf_unitary_type "arrow" thf_unitary_type action_73 { LogicFormulaEntry(t2) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->(List(t1, t2)))) :: rest }
  |thf_unitary_type "arrow" thf_mapping_type action_74 { LogicFormulaEntry(BinType(->(l))) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->( t1 :: l ))) :: rest }
thf_unitary_type ->
   thf_unitary_formula action_75
thf_xprod_type ->
   thf_unitary_type "star" thf_unitary_type action_76 { LogicFormulaEntry(t2) :: TokenEntry(Star) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(*(List(t1, t2)))) :: rest }
  |thf_xprod_type "star" thf_unitary_type action_77 { LogicFormulaEntry(t1) :: TokenEntry(Star) :: LogicFormulaEntry(BinType(*(l))) :: rest => LogicFormulaEntry(BinType(*( l :+ t1 ))) :: rest }
thf_union_type ->
   thf_unitary_type "plus" thf_unitary_type action_78 { LogicFormulaEntry(t2) :: TokenEntry(Plus) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(+(List(t1, t2)))) :: rest }
  |thf_union_type "plus" thf_unitary_type action_79 { LogicFormulaEntry(t1) :: TokenEntry(Plus) :: LogicFormulaEntry(BinType(+(l))) :: rest => LogicFormulaEntry(BinType(+( l :+ t1 ))) :: rest }
thf_type_formula ->
   thf_typeable_formula ":" thf_top_level_type action_80 { LogicFormulaEntry(t) :: TokenEntry(Colon) :: LogicFormulaEntry(f) :: rest => LogicFormulaEntry(Typed(formula=f, typ=t)) :: rest }
thf_typeable_formula ->
   thf_atom action_81
  |"(" thf_logic_formula ")" action_82 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: rest => LogicFormulaEntry(f) :: rest }
thf_subtype ->
   constant subtype_sign constant action_83 { TokenEntry(LowerWord(x2)) :: TokenEntry(LessSign) :: TokenEntry(LessSign) :: TokenEntry(LowerWord(x1)) :: rest => LogicFormulaEntry(Subtype(x1, x2)) :: rest }
constant ->
   functor action_84
functor ->
   atomic_word action_85
atomic_word ->
   "lower_word" action_86
  |"single_quoted" action_87
subtype_sign ->
   "less_sign" "less_sign" action_88
thf_sequent ->
   thf_tuple gentzen_arrow thf_tuple action_89 { LogicFormulasEntry(f2) :: TokenEntry(Arrow) :: TokenEntry(Minus) :: TokenEntry(Minus) :: LogicFormulasEntry(f1) :: rest => FormulaEntry(Sequent(tuple1=f1, tuple2=f2)) :: rest }
  |"(" thf_sequent ")" action_90 { TokenEntry(RightParenthesis) :: FormulaEntry(sequent: Sequent) :: TokenEntry(LeftParenthesis) :: rest => FormulaEntry(sequent) :: rest }
thf_tuple ->
   "[" "]" action_91 { TokenEntry(RightBracket) :: TokenEntry(LeftBracket) :: rest => LogicFormulasEntry(List[LogicFormula]()) :: rest }
  |"[" thf_tuple_list "]" action_92 { TokenEntry(RightBracket) :: LogicFormulasEntry(tuple) :: TokenEntry(LeftBracket) :: rest => LogicFormulasEntry(tuple) :: rest }
thf_tuple_list ->
   thf_logic_formula action_93 { LogicFormulaEntry(tuple) :: rest => LogicFormulasEntry(List(tuple)) :: rest }
  |thf_logic_formula "," thf_tuple_list action_94 { LogicFormulasEntry(list) :: TokenEntry(Comma) :: LogicFormulaEntry(formula) :: rest => LogicFormulasEntry(formula :: list) :: rest }
gentzen_arrow ->
   "-" "-" "arrow" action_95

  /* this is the type of the nodes of the abstract syntax tree: */
  sealed class StackEntry
    case class TokenEntry(data: Token) extends StackEntry
    case class FormulaEntry(data: Formula) extends StackEntry
    case class LogicFormulaEntry(data: LogicFormula) extends StackEntry
    case class VarsEntry(data: List[(Commons.Variable, Option[LogicFormula])]) extends StackEntry
    case class VarEntry(data: (Commons.Variable, Option[LogicFormula])) extends StackEntry
    case class UnaryConnectiveEntry(data: UnaryConnective) extends StackEntry
    case class BinaryConnectiveEntry(data: BinaryConnective) extends StackEntry
    case class QuantifierEntry(data: Quantifier) extends StackEntry
    case class TermEntry(data: Commons.Term) extends StackEntry
    case class LogicFormulasEntry(data: List[LogicFormula]) extends StackEntry

