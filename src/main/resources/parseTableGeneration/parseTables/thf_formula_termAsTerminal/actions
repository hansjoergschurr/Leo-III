action_1 { LogicFormulaEntry(f) :: rest => FormulaEntry(f) :: rest } 
	 thf_formula -> thf_logic_formula
action_10 { LogicFormulaEntry(f2) :: BinaryConnectiveEntry(conn) :: LogicFormulaEntry(f1) :: rest => LogicFormulaEntry( Binary(left=f1, connective=conn, right=f2 ) ) :: rest } 
	 thf_binary_pair -> thf_unitary_formula thf_pair_connective thf_unitary_formula
action_16 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: rest => LogicFormulaEntry(f) :: rest } 
	 thf_unitary_formula -> "(" thf_logic_formula ")"
action_17 { LogicFormulaEntry(f) :: TokenEntry(Colon) :: TokenEntry(RightBracket) :: VarsEntry(vars) :: TokenEntry(LeftBracket) :: QuantifierEntry(q) :: rest => LogicFormulaEntry(Quantified(quantifier=q, varList=vars, matrix=f )) :: rest } 
	 thf_quantified_formula -> thf_quantifier "[" thf_variable_list "]" ":" thf_unitary_formula
action_18 { TokenEntry(x) :: rest => QuantifierEntry(quantifierFromToken_1(x)) :: rest } 
	 thf_quantifier -> fol_quantifier
action_19 { action_18 } 
	 thf_quantifier -> "^"
action_20 { TokenEntry(x2) :: TokenEntry(x1) :: rest => QuantifierEntry(quantifierFromToken_2(x1,x2)) :: rest } 
	 thf_quantifier -> "!" "arrow"
action_21 { action_20 } 
	 thf_quantifier -> "?" "star"
action_22 { action_20 } 
	 thf_quantifier -> "@" "plus"
action_23 { action_20 } 
	 thf_quantifier -> "@" "-"
action_26 { VarEntry(v) :: rest => VarsEntry(List(v)) :: rest } 
	 thf_variable_list -> thf_variable
action_27 { VarsEntry(vars) :: TokenEntry(Comma) :: VarEntry(v) :: rest => VarsEntry(v :: vars) :: rest } 
	 thf_variable_list -> thf_variable "," thf_variable_list
action_30 { LogicFormulaEntry(t) :: TokenEntry(Colon) :: VarEntry((v, None)) :: rest => VarEntry((v, Some(t))) :: rest } 
	 thf_typed_variable -> variable ":" thf_top_level_type
action_31 { TokenEntry(UpperWord(v)) :: rest => VarEntry((v, None)) :: rest } 
	 variable -> "upper_word"
action_33 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: UnaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Unary(connective=conn, formula=f)) :: rest } 
	 thf_unary_formula -> thf_unary_connective "(" thf_logic_formula ")"
action_35 { TokenEntry(Exclamationmark) :: TokenEntry(Exclamationmark) :: rest => UnaryConnectiveEntry(!!) :: rest } 
	 thf_unary_connective -> "!" "!"
action_36 { TokenEntry(Questionmark) :: TokenEntry(Questionmark) :: rest => UnaryConnectiveEntry(??) :: rest } 
	 thf_unary_connective -> "?" "?"
action_37 { TokenEntry(Tilde) :: rest => UnaryConnectiveEntry(~) :: rest } 
	 unary_connective -> "~"
action_38 { TermEntry(t) :: rest => LogicFormulaEntry(Term(t)) :: rest } 
	 thf_atom -> "term"
action_40 { BinaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Connective(Left(conn))) :: rest } 
	 thf_conn_term -> thf_pair_connective
action_41 { action_40 } 
	 thf_conn_term -> assoc_connective
action_42 { UnaryConnectiveEntry(conn) :: rest => LogicFormulaEntry(Connective(Right(conn))) :: rest } 
	 thf_conn_term -> thf_unary_connective
action_46 { TokenEntry(x) :: rest => BinaryConnectiveEntry(binaryConnectiveFromToken_1(x)) :: rest } 
	 infix_equality -> "="
action_47 { action_46 } 
	 infix_inequality -> "!="
action_48 { action_46 } 
	 binary_connective -> "less_eq_greater"
action_49 { action_46 } 
	 binary_connective -> "=>"
action_50 { action_46 } 
	 binary_connective -> "less_eq"
action_51 { action_46 } 
	 binary_connective -> "less_tilde_greater"
action_52 { action_46 } 
	 binary_connective -> "~vline"
action_53 { action46 } 
	 binary_connective -> "~&"
action_54 { action_46 } 
	 assoc_connective -> "vline"
action_55 { action_46 } 
	 assoc_connective -> "&"
action_56 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(elseFormula) :: TokenEntry(Comma) :: LogicFormulaEntry(thenFormula) :: TokenEntry(Comma) :: LogicFormulaEntry(condFormula) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$ite_f")) :: rest => LogicFormulaEntry(Cond(cond=condFormula, thn=thenFormula, els=elseFormula)) :: rest } 
	 thf_conditional -> "$ite_f" "(" thf_logic_formula "," thf_logic_formula "," thf_logic_formula ")"
action_57 { TokenEntry(RightParenthesis) :: FormulaEntry(f) :: TokenEntry(Comma) :: LogicFormulaEntry(let_def: Quantified) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$let_tf")) :: rest => LogicFormulaEntry(Let(TermBinding(let_def),f)) :: rest } 
	 thf_let -> "$let_tf" "(" thf_let_term_defn "," thf_formula ")"
action_58 { TokenEntry(RightParenthesis) :: FormulaEntry(f) :: TokenEntry(Comma) :: LogicFormulaEntry(let_def: Quantified) :: TokenEntry(LeftParenthesis) :: TokenEntry(DollarWord("$let_ff")) :: rest => LogicFormulaEntry(Let(FormulaBinding(let_def),f)) :: rest } 
	 thf_let -> "$let_ff" "(" thf_let_formula_defn "," thf_formula ")"
action_64 { LogicFormulaEntry(f2) :: TokenEntry(conn) :: LogicFormulaEntry(f1) :: rest => LogicFormulaEntry(Binary(left=f1, connective= binaryConnectiveFromToken_1(conn), right=f2)) :: rest } 
	 thf_or_formula -> thf_unitary_formula "vline" thf_unitary_formula
action_65 { action_64 } 
	 thf_or_formula -> thf_or_formula "vline" thf_unitary_formula
action_66 { action_64 } 
	 thf_and_formula -> thf_unitary_formula "&" thf_unitary_formula
action_67 { action_64 } 
	 thf_and_formula -> thf_and_formula "&" thf_unitary_formula
action_68 { action_64 } 
	 thf_apply_formula -> thf_unitary_formula "@" thf_unitary_formula
action_69 { action_64 } 
	 thf_apply_formula -> thf_apply_formula "@" thf_unitary_formula
action_73 { LogicFormulaEntry(t2) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->(List(t1, t2)))) :: rest } 
	    thf_unitary_type "arrow" thf_unitary_type action_73 { LogicFormulaEntry(t2) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->(List(t1, t2)))) :: rest } thf_unitary_type "arrow" thf_unitary_type
action_74 { LogicFormulaEntry(BinType(->(l))) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->( t1 :: l ))) :: rest } 
	   |thf_unitary_type "arrow" thf_mapping_type action_74 { LogicFormulaEntry(BinType(->(l))) :: TokenEntry(Arrow) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(->( t1 :: l ))) :: rest } thf_unitary_type "arrow" thf_mapping_type
action_76 { LogicFormulaEntry(t2) :: TokenEntry(Star) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(*(List(t1, t2)))) :: rest } 
	 thf_xprod_type -> thf_unitary_type "star" thf_unitary_type
action_77 { LogicFormulaEntry(t1) :: TokenEntry(Star) :: LogicFormulaEntry(BinType(*(l))) :: rest => LogicFormulaEntry(BinType(*( l :+ t1 ))) :: rest } 
	 thf_xprod_type -> thf_xprod_type "star" thf_unitary_type
action_78 { LogicFormulaEntry(t2) :: TokenEntry(Plus) :: LogicFormulaEntry(t1) :: rest => LogicFormulaEntry(BinType(+(List(t1, t2)))) :: rest } 
	 thf_union_type -> thf_unitary_type "plus" thf_unitary_type
action_79 { LogicFormulaEntry(t1) :: TokenEntry(Plus) :: LogicFormulaEntry(BinType(+(l))) :: rest => LogicFormulaEntry(BinType(+( l :+ t1 ))) :: rest } 
	 thf_union_type -> thf_union_type "plus" thf_unitary_type
action_80 { LogicFormulaEntry(t) :: TokenEntry(Colon) :: LogicFormulaEntry(f) :: rest => LogicFormulaEntry(Typed(formula=f, typ=t)) :: rest } 
	 thf_type_formula -> thf_typeable_formula ":" thf_top_level_type
action_82 { TokenEntry(RightParenthesis) :: LogicFormulaEntry(f) :: TokenEntry(LeftParenthesis) :: rest => LogicFormulaEntry(f) :: rest } 
	 thf_typeable_formula -> "(" thf_logic_formula ")"
action_83 { TokenEntry(LowerWord(x2)) :: TokenEntry(LessSign) :: TokenEntry(LessSign) :: TokenEntry(LowerWord(x1)) :: rest => LogicFormulaEntry(Subtype(x1, x2)) :: rest } 
	 thf_subtype -> constant subtype_sign constant
action_89 { LogicFormulasEntry(f2) :: TokenEntry(Arrow) :: TokenEntry(Minus) :: TokenEntry(Minus) :: LogicFormulasEntry(f1) :: rest => FormulaEntry(Sequent(tuple1=f1, tuple2=f2)) :: rest } 
	 thf_sequent -> thf_tuple gentzen_arrow thf_tuple
action_90 { TokenEntry(RightParenthesis) :: FormulaEntry(sequent: Sequent) :: TokenEntry(LeftParenthesis) :: rest => FormulaEntry(sequent) :: rest } 
	 thf_sequent -> "(" thf_sequent ")"
action_91 { TokenEntry(RightBracket) :: TokenEntry(LeftBracket) :: rest => LogicFormulasEntry(List[LogicFormula]()) :: rest } 
	 thf_tuple -> "[" "]"
action_92 { TokenEntry(RightBracket) :: LogicFormulasEntry(tuple) :: TokenEntry(LeftBracket) :: rest => LogicFormulasEntry(tuple) :: rest } 
	 thf_tuple -> "[" thf_tuple_list "]"
action_93 { LogicFormulaEntry(tuple) :: rest => LogicFormulasEntry(List(tuple)) :: rest } 
	 thf_tuple_list -> thf_logic_formula
action_94 { LogicFormulasEntry(list) :: TokenEntry(Comma) :: LogicFormulaEntry(formula) :: rest => LogicFormulasEntry(formula :: list) :: rest } 
	 thf_tuple_list -> thf_logic_formula "," thf_tuple_list
